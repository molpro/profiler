<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>profiler: Profiler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">profiler
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Profiler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md____w_profiler_profiler_README"></a></p>
<p>Full documentation can be found here <a href="https://molpro.github.io/profiler">https://molpro.github.io/profiler</a>.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Overview</h1>
<p>Framework for timing sections of code in serial and parallel, implemented in C++ with C and Fortran wrappers.</p>
<p><b>Disclaimer</b>, this is an instrumental profiler and timing statements have to be added to the source code. This can degrade overall performance and distort real profile if attempting to time tight loops.</p>
<p>The profiler works by constructing a call tree and accumulating call count, operation count, and timing duration in each node. Optionally, but typically with significantly greater overhead, CPU time can be recorded also. The maximum depth of profiler tree can also be limited, resulting in any calls to start() that would grow the tree beyond the limit to do nothing. This allows Profiler to be used in production code without degrading performance. The profile tree can be analysed and printed.</p>
<p>In the following simple example, calling <em>start()</em> on profiler moves down the call tree and starts timing and calling <em>stop()</em> moves up to the parent and stops timing. The same effect can be achieved on a scope level by calling <em>push()</em> which returns a proxy that starts profiling on construction and stops on destruction. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;molpro/Profiler.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_input(Profiler&amp;);</div>
<div class="line"><span class="keywordtype">void</span> restore_backup(Profiler&amp;);</div>
<div class="line"><span class="keywordtype">void</span> operation1();</div>
<div class="line"><span class="keywordtype">void</span> operation2();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keyword">auto</span> prof = <a class="code" href="classmolpro_1_1profiler_1_1Profiler.html">molpro::Profiler</a>{<span class="stringliteral">&quot;main()&quot;</span>};</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> p = prof.<a class="code" href="classmolpro_1_1profiler_1_1Profiler.html#ac38692f6d56f4ea12acebe8195b1b20d">push</a>(<span class="stringliteral">&quot;initialise()&quot;</span>);</div>
<div class="line">        <span class="comment">// ....</span></div>
<div class="line">        read_input(prof);</div>
<div class="line">        restore_backup(prof);</div>
<div class="line">    }</div>
<div class="line">    prof.start(<span class="stringliteral">&quot;perform_calculation()&quot;</span>);</div>
<div class="line">    <span class="comment">// ....</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i){</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> p = prof.push(<span class="stringliteral">&quot;operation1()&quot;</span>);</div>
<div class="line">            operation1();</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> p = prof.push(<span class="stringliteral">&quot;operation2()&quot;</span>);</div>
<div class="line">            operation2();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    prof.stop();</div>
<div class="line">    std::cout &lt;&lt; prof &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">// Or directly call report()</span></div>
<div class="line">    <a class="code" href="namespacemolpro_1_1profiler.html#ac11f7b0c852f3f13febeb7abcf47e76c">report</a>(prof, std::cout);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassmolpro_1_1profiler_1_1Profiler_html"><div class="ttname"><a href="classmolpro_1_1profiler_1_1Profiler.html">molpro::profiler::Profiler</a></div><div class="ttdoc">Instrumental profiler for timing sections of code.</div><div class="ttdef"><b>Definition:</b> Profiler.h:41</div></div>
<div class="ttc" id="aclassmolpro_1_1profiler_1_1Profiler_html_ac38692f6d56f4ea12acebe8195b1b20d"><div class="ttname"><a href="classmolpro_1_1profiler_1_1Profiler.html#ac38692f6d56f4ea12acebe8195b1b20d">molpro::profiler::Profiler::push</a></div><div class="ttdeci">Proxy push(const std::string &amp;name)</div><div class="ttdoc">Returns a proxy object which will start() on construction and stop on destruction.</div><div class="ttdef"><b>Definition:</b> Profiler.h:151</div></div>
<div class="ttc" id="anamespacemolpro_1_1profiler_html_ac11f7b0c852f3f13febeb7abcf47e76c"><div class="ttname"><a href="namespacemolpro_1_1profiler.html#ac11f7b0c852f3f13febeb7abcf47e76c">molpro::profiler::report</a></div><div class="ttdeci">void report(const std::shared_ptr&lt; Node&lt; Counter &gt;&gt; &amp;root, const std::string &amp;description, std::ostream &amp;out, bool cumulative=true, SortBy sort_by=SortBy::wall)</div><div class="ttdoc">Reports the content of a Profiler call subtree.</div><div class="ttdef"><b>Definition:</b> report.cpp:209</div></div>
</div><!-- fragment --><p>Here is a visual representation of the profiler call tree during execution.</p>
<p><img src="doc/profiler.gif" alt="" width="800" class="inline"/></p>
<p>At the end of calculation the profiler can be analysed and printed out. By default, the call tree is sorted by wall time at each level and cumulative times are used. </p><div class="fragment"><div class="line">Profiler &quot;main()&quot; (cumulative)</div>
<div class="line">All                   : calls=1, wall=18</div>
<div class="line">.perform_calculation(): calls=1, wall=10</div>
<div class="line">..operation2()        : calls=2, wall=4</div>
<div class="line">..operation1()        : calls=2, wall=4</div>
<div class="line">.initialise()         : calls=1, wall=6</div>
<div class="line">..restore_backup()    : calls=1, wall=2</div>
<div class="line">..read_input()        : calls=1, wall=2</div>
</div><!-- fragment --><p>Alternatively, cumulative format can be turned off using <code>prof.str(false)</code> then time spent on each call excluding any children is shown. </p><div class="fragment"><div class="line">Profiler &quot;main()&quot;</div>
<div class="line">                           (other): calls=1, wall=2</div>
<div class="line">             perform_calculation(): calls=1, wall=2</div>
<div class="line">perform_calculation():operation1(): calls=2, wall=4</div>
<div class="line">perform_calculation():operation2(): calls=2, wall=4</div>
<div class="line">                      initialise(): calls=1, wall=2</div>
<div class="line">         initialise():read_input(): calls=1, wall=2</div>
<div class="line">     initialise():restore_backup(): calls=1, wall=2</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1"></a>
Weak Singleton pattern</h1>
<p>During development and debugging it becomes inconvenient to pass a profiler instance down through all function calls. Instead, one can use the weak Singleton interface to access a profiler that was created at higher scope. For example,</p>
<div class="fragment"><div class="line"><span class="comment">// File: main.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;molpro/Profiler.h&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> run();</div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    std::shared_ptr&lt;Profiler&gt; prof = <a class="code" href="classmolpro_1_1profiler_1_1Profiler.html#aea6108170dddaa5caafb2df4ec42db5d">molpro::Profiler::single</a>(<span class="stringliteral">&quot;MainProfiler&quot;</span>);</div>
<div class="line">    run();</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassmolpro_1_1profiler_1_1Profiler_html_aea6108170dddaa5caafb2df4ec42db5d"><div class="ttname"><a href="classmolpro_1_1profiler_1_1Profiler.html#aea6108170dddaa5caafb2df4ec42db5d">molpro::profiler::Profiler::single</a></div><div class="ttdeci">static std::shared_ptr&lt; Profiler &gt; single()</div><div class="ttdoc">Access the last registered Profiler.</div><div class="ttdef"><b>Definition:</b> Profiler.cpp:31</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// File: run.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;molpro/Profiler.h&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> run(){</div>
<div class="line">    <span class="keyword">auto</span> p = <a class="code" href="classmolpro_1_1profiler_1_1Profiler.html#aea6108170dddaa5caafb2df4ec42db5d">molpro::Profiler::single</a>()-&gt;push(<span class="stringliteral">&quot;run()&quot;</span>);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The main routine creates a profiler instance that is registered as a static weak_ptr and can be accessed at lower levels through <b><a class="el" href="classmolpro_1_1profiler_1_1Profiler.html#aea6108170dddaa5caafb2df4ec42db5d" title="Access the last registered Profiler.">molpro::Profiler::single()</a></b>. This pattern avoids the pitfalls of the traditional Singleton by keeping Profiler instance on the heap with scoped memory management and only storing a non-owning pointer on the stack.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Profiling and Reporting</h1>
<p>Profiling is performed by <code><a class="el" href="classmolpro_1_1profiler_1_1Profiler.html" title="Instrumental profiler for timing sections of code.">molpro::profiler::Profiler</a></code> class, there is an alias to it in <code><a class="el" href="Profiler_8h_source.html">molpro/Profiler.h</a></code>. The results of Profiler can be reported using <code><a class="el" href="namespacemolpro_1_1profiler.html#ac11f7b0c852f3f13febeb7abcf47e76c" title="Reports the content of a Profiler call subtree.">molpro::profiler::report()</a></code> functions in <code><a class="el" href="report_8h_source.html">molpro/profiler/report.h</a></code></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Features</h1>
<ul>
<li>Constructs profiler call tree and accumulates statistics for each node</li>
<li>Multiple call trees can be processed, allowing simple use in parallel applications</li>
<li>management of global Profiler objects using a singleton class</li>
<li>includes Fotran and C bindings</li>
<li>easily integration into the build system with CMake</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
CMake build</h1>
<p>Profiler can be added to an existing project that uses CMake by downloading it with FetchContent. If Fortran compilers or MPI are enabled during the CMake build than relevant Profiler functionality will be build automatically. Simply link <b><a class="el" href="namespacemolpro_1_1profiler.html">molpro::profiler</a></b> target to your library.</p>
<p>Profiler uses <a href="https://github.com/molpro/dependency-manager">DependencyManager</a> and hosts its doxygen tag files. You can link your doxygen generated documentation with Profiler using <a href="https://molpro.github.io/dependency-manager/dependency_manager_docs.html">DependencyManager_Doc</a>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Contributors</h1>
<p>Peter J. Knowles</p>
<p>Marat Sibaev</p>
<p>Iakov Polyak</p>
<p>Rob Welch</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Licence</h1>
<p>MIT License Copyright (c) 2020 Peter James Knowles </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
